# Hashes on hashes on hashes

Author: Joram

This challenge gives users the code for an encryption server, as well a log file generated by that code being run. The encryption server takes encrypted base64 data through a socket, runs it through an XOR decryption with a key loaded from another file, then sends the decrypted text back through the socket. However, the logging function on the program saves too much information, specifically hashes of the plaintext each time a character is added. Having access to this log file, an attacker can recreate the decrypted messages by brute forcing the hashes one character at a time.

## Brute Forcing the Hashes

Based on the code, you can see that an md5 hash is generated each time a new character is decrypted in the XOR operation.

```python
for i in range(len(enc_bytes)):
        dec_bytes.append(enc_bytes[i] ^ key_bytes[i])
        log.print(f"Partial message digest is {md5(dec_bytes).hexdigest()}")
```

This means the first hash in a group will be of a single character string. The second hash in a group will be of a two character string, and etc.

```
25/02/2024 01:23:55	Received encrypted message JAsOFARRHQMdHQ9d
25/02/2024 01:23:55	Key loaded for encrypted message
25/02/2024 01:23:55	Key expanded by factor of 1
25/02/2024 01:23:55	Partial message digest is c1d9f50f86825a1a2302ec2449c17196 # This hash is of a one character string
25/02/2024 01:23:55	Partial message digest is a64cf5823262686e1a28b2245be34ce0 # This hash is of the previous string plus one new character (total length of 2)
25/02/2024 01:23:55	Partial message digest is 6b6e667a40e816c4da7bb4ab64cbb82b # This hash is of the previous string plus one new character (total length of 3)
...
```

The first hash can be easily brute forced by hashing all printable characters and comparing them to the hash.

```python
# Generate hashes for all printable characters
hashes = {}
for s in string.printable:
    hashes[s] = md5(s.encode()).hexdigest()

...

# Use hash dictionary to find correct character
plaintext = ''
# file_hash = first hash from file
for test_char in hashes.keys():
    # Compare hash of guess to hash in log file
    if(hashes[test_char] == file_hash):
        plaintext += test_char
        break
```


Once you've discovered the first character of the message this way, you can proceed by iterating through all printable characters as the second character of the message, and comparing those hashes to the second hash from the log file. Repeating this process with loops, you can reverse engineer the entire message.

```python
# Iterate through all groups of hashes
for hash_group in hash_groups:
    crib = ''
    # Iterate through each hash in the group
    for this_hash in hash_group:
        # Start iterating through each possible character added by the hash, breaking on success
        for test_char in hashes.keys():
            crib_guess = crib + test_char
            # Compare hash of guess to hash in log file
            test_hash = md5(crib_guess.encode()).hexdigest()
            if(test_hash == this_hash):
                crib += test_char
                break
    # Print decrypted message
    print(crib)
```

## Solve Script

This reverse engineering technique can be achieved using this solve script written in python:

```python
from hashlib import md5
import string

# Generate hashes for each single character
hashes = {}
for s in string.printable:
    hashes[s] = md5(s.encode()).hexdigest()
#print(hashes)

# Load all groups of hashes from the log file (this is probably not the cleanest way but it works)
data = open('decryption_server.log', 'r').readlines()
filtered = [s.strip().split(' ')[-1] for s in data if 'digest' in s or 'factor' in s]

hash_groups = []
hash_group = []
for l in filtered:
    if(len(l) == 1):
        hash_groups.append(hash_group)
        hash_group = []
    else:
        hash_group.append(l)
hash_groups.append(hash_group)
hash_groups = hash_groups[1:]

# Iterate through all groups of hashes
for hash_group in hash_groups:
    crib = ''
    # Iterate through each hash in the group
    for this_hash in hash_group:
        # Start iterating through each possible character added by the hash, breaking on success
        for test_char in hashes.keys():
            crib_guess = crib + test_char
            # Compare hash of guess to hash in log file
            test_hash = md5(crib_guess.encode()).hexdigest()
            if(test_hash == this_hash):
                crib += test_char
                break
    # Print decrypted message
    print(crib)
```

## Solution Script Output

```
Hello there.
General Kenobi, you are a bold one.
Your move.
You fool. I've been trained in your cryptography arts by Count Dooku!
Attack, Kenobi! flag{a23f721aeff7b65bc87e24015a54aa53}
So uncivilized...
```